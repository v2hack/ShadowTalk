// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: share.proto

#ifndef PROTOBUF_share_2eproto__INCLUDED
#define PROTOBUF_share_2eproto__INCLUDED

#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable: 4127 4244 4267)
#endif

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace peersafe {
namespace share {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_share_2eproto();
void protobuf_AssignDesc_share_2eproto();
void protobuf_ShutdownFile_share_2eproto();

class ShareFile;
class ShareListSubItem;
class ShareListItem;
class ShareList;
class ShareSubCommen;
class ShareComment;
class ShareContent;

enum ShareFile_FileType {
  ShareFile_FileType_FILE_TYPE_SHARE_LIST = 1,
  ShareFile_FileType_FILE_TYPE_SHARE_CONTENT = 2,
  ShareFile_FileType_FILE_TYPE_SHARE_COMMENT = 3
};
bool ShareFile_FileType_IsValid(int value);
const ShareFile_FileType ShareFile_FileType_FileType_MIN = ShareFile_FileType_FILE_TYPE_SHARE_LIST;
const ShareFile_FileType ShareFile_FileType_FileType_MAX = ShareFile_FileType_FILE_TYPE_SHARE_COMMENT;
const int ShareFile_FileType_FileType_ARRAYSIZE = ShareFile_FileType_FileType_MAX + 1;

enum ShareListSubItem_ContentType {
  ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_WORDS = 1,
  ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_IMAGE = 2,
  ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_AUDIO = 3,
  ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_VEDIO = 4,
  ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_PDF = 5,
  ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_OFFICE_WORD = 6,
  ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_OFFICE_EXCEL = 7
};
bool ShareListSubItem_ContentType_IsValid(int value);
const ShareListSubItem_ContentType ShareListSubItem_ContentType_ContentType_MIN = ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_WORDS;
const ShareListSubItem_ContentType ShareListSubItem_ContentType_ContentType_MAX = ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_OFFICE_EXCEL;
const int ShareListSubItem_ContentType_ContentType_ARRAYSIZE = ShareListSubItem_ContentType_ContentType_MAX + 1;

// ===================================================================

class ShareFile : public ::google::protobuf::MessageLite {
 public:
  ShareFile();
  virtual ~ShareFile();

  ShareFile(const ShareFile& from);

  inline ShareFile& operator=(const ShareFile& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShareFile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShareFile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShareFile* other);

  // implements Message ----------------------------------------------

  ShareFile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShareFile& from);
  void MergeFrom(const ShareFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ShareFile_FileType FileType;
  static const FileType FILE_TYPE_SHARE_LIST = ShareFile_FileType_FILE_TYPE_SHARE_LIST;
  static const FileType FILE_TYPE_SHARE_CONTENT = ShareFile_FileType_FILE_TYPE_SHARE_CONTENT;
  static const FileType FILE_TYPE_SHARE_COMMENT = ShareFile_FileType_FILE_TYPE_SHARE_COMMENT;
  static inline bool FileType_IsValid(int value) {
    return ShareFile_FileType_IsValid(value);
  }
  static const FileType FileType_MIN =
    ShareFile_FileType_FileType_MIN;
  static const FileType FileType_MAX =
    ShareFile_FileType_FileType_MAX;
  static const int FileType_ARRAYSIZE =
    ShareFile_FileType_FileType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .peersafe.share.ShareFile.FileType file_type = 1;
  inline bool has_file_type() const;
  inline void clear_file_type();
  static const int kFileTypeFieldNumber = 1;
  inline ::peersafe::share::ShareFile_FileType file_type() const;
  inline void set_file_type(::peersafe::share::ShareFile_FileType value);

  // optional bytes file_data = 2;
  inline bool has_file_data() const;
  inline void clear_file_data();
  static const int kFileDataFieldNumber = 2;
  inline const ::std::string& file_data() const;
  inline void set_file_data(const ::std::string& value);
  inline void set_file_data(const char* value);
  inline void set_file_data(const void* value, size_t size);
  inline ::std::string* mutable_file_data();
  inline ::std::string* release_file_data();
  inline void set_allocated_file_data(::std::string* file_data);

  // @@protoc_insertion_point(class_scope:peersafe.share.ShareFile)
 private:
  inline void set_has_file_type();
  inline void clear_has_file_type();
  inline void set_has_file_data();
  inline void clear_has_file_data();

  ::std::string* file_data_;
  int file_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_share_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_share_2eproto();
  #endif
  friend void protobuf_AssignDesc_share_2eproto();
  friend void protobuf_ShutdownFile_share_2eproto();

  void InitAsDefaultInstance();
  static ShareFile* default_instance_;
};
// -------------------------------------------------------------------

class ShareListSubItem : public ::google::protobuf::MessageLite {
 public:
  ShareListSubItem();
  virtual ~ShareListSubItem();

  ShareListSubItem(const ShareListSubItem& from);

  inline ShareListSubItem& operator=(const ShareListSubItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShareListSubItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShareListSubItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShareListSubItem* other);

  // implements Message ----------------------------------------------

  ShareListSubItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShareListSubItem& from);
  void MergeFrom(const ShareListSubItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ShareListSubItem_ContentType ContentType;
  static const ContentType SHARE_CONTENT_TYPE_WORDS = ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_WORDS;
  static const ContentType SHARE_CONTENT_TYPE_IMAGE = ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_IMAGE;
  static const ContentType SHARE_CONTENT_TYPE_AUDIO = ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_AUDIO;
  static const ContentType SHARE_CONTENT_TYPE_VEDIO = ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_VEDIO;
  static const ContentType SHARE_CONTENT_TYPE_PDF = ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_PDF;
  static const ContentType SHARE_CONTENT_TYPE_OFFICE_WORD = ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_OFFICE_WORD;
  static const ContentType SHARE_CONTENT_TYPE_OFFICE_EXCEL = ShareListSubItem_ContentType_SHARE_CONTENT_TYPE_OFFICE_EXCEL;
  static inline bool ContentType_IsValid(int value) {
    return ShareListSubItem_ContentType_IsValid(value);
  }
  static const ContentType ContentType_MIN =
    ShareListSubItem_ContentType_ContentType_MIN;
  static const ContentType ContentType_MAX =
    ShareListSubItem_ContentType_ContentType_MAX;
  static const int ContentType_ARRAYSIZE =
    ShareListSubItem_ContentType_ContentType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 share_content_type = 1;
  inline bool has_share_content_type() const;
  inline void clear_share_content_type();
  static const int kShareContentTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 share_content_type() const;
  inline void set_share_content_type(::google::protobuf::uint32 value);

  // required bytes share_file_name = 2;
  inline bool has_share_file_name() const;
  inline void clear_share_file_name();
  static const int kShareFileNameFieldNumber = 2;
  inline const ::std::string& share_file_name() const;
  inline void set_share_file_name(const ::std::string& value);
  inline void set_share_file_name(const char* value);
  inline void set_share_file_name(const void* value, size_t size);
  inline ::std::string* mutable_share_file_name();
  inline ::std::string* release_share_file_name();
  inline void set_allocated_share_file_name(::std::string* share_file_name);

  // required bytes thumbnail_file_name = 3;
  inline bool has_thumbnail_file_name() const;
  inline void clear_thumbnail_file_name();
  static const int kThumbnailFileNameFieldNumber = 3;
  inline const ::std::string& thumbnail_file_name() const;
  inline void set_thumbnail_file_name(const ::std::string& value);
  inline void set_thumbnail_file_name(const char* value);
  inline void set_thumbnail_file_name(const void* value, size_t size);
  inline ::std::string* mutable_thumbnail_file_name();
  inline ::std::string* release_thumbnail_file_name();
  inline void set_allocated_thumbnail_file_name(::std::string* thumbnail_file_name);

  // required bytes thumbnail_data = 4;
  inline bool has_thumbnail_data() const;
  inline void clear_thumbnail_data();
  static const int kThumbnailDataFieldNumber = 4;
  inline const ::std::string& thumbnail_data() const;
  inline void set_thumbnail_data(const ::std::string& value);
  inline void set_thumbnail_data(const char* value);
  inline void set_thumbnail_data(const void* value, size_t size);
  inline ::std::string* mutable_thumbnail_data();
  inline ::std::string* release_thumbnail_data();
  inline void set_allocated_thumbnail_data(::std::string* thumbnail_data);

  // required bytes share_content_hash = 5;
  inline bool has_share_content_hash() const;
  inline void clear_share_content_hash();
  static const int kShareContentHashFieldNumber = 5;
  inline const ::std::string& share_content_hash() const;
  inline void set_share_content_hash(const ::std::string& value);
  inline void set_share_content_hash(const char* value);
  inline void set_share_content_hash(const void* value, size_t size);
  inline ::std::string* mutable_share_content_hash();
  inline ::std::string* release_share_content_hash();
  inline void set_allocated_share_content_hash(::std::string* share_content_hash);

  // required bytes share_comment_hash = 6;
  inline bool has_share_comment_hash() const;
  inline void clear_share_comment_hash();
  static const int kShareCommentHashFieldNumber = 6;
  inline const ::std::string& share_comment_hash() const;
  inline void set_share_comment_hash(const ::std::string& value);
  inline void set_share_comment_hash(const char* value);
  inline void set_share_comment_hash(const void* value, size_t size);
  inline ::std::string* mutable_share_comment_hash();
  inline ::std::string* release_share_comment_hash();
  inline void set_allocated_share_comment_hash(::std::string* share_comment_hash);

  // @@protoc_insertion_point(class_scope:peersafe.share.ShareListSubItem)
 private:
  inline void set_has_share_content_type();
  inline void clear_has_share_content_type();
  inline void set_has_share_file_name();
  inline void clear_has_share_file_name();
  inline void set_has_thumbnail_file_name();
  inline void clear_has_thumbnail_file_name();
  inline void set_has_thumbnail_data();
  inline void clear_has_thumbnail_data();
  inline void set_has_share_content_hash();
  inline void clear_has_share_content_hash();
  inline void set_has_share_comment_hash();
  inline void clear_has_share_comment_hash();

  ::std::string* share_file_name_;
  ::std::string* thumbnail_file_name_;
  ::std::string* thumbnail_data_;
  ::std::string* share_content_hash_;
  ::std::string* share_comment_hash_;
  ::google::protobuf::uint32 share_content_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_share_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_share_2eproto();
  #endif
  friend void protobuf_AssignDesc_share_2eproto();
  friend void protobuf_ShutdownFile_share_2eproto();

  void InitAsDefaultInstance();
  static ShareListSubItem* default_instance_;
};
// -------------------------------------------------------------------

class ShareListItem : public ::google::protobuf::MessageLite {
 public:
  ShareListItem();
  virtual ~ShareListItem();

  ShareListItem(const ShareListItem& from);

  inline ShareListItem& operator=(const ShareListItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShareListItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShareListItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShareListItem* other);

  // implements Message ----------------------------------------------

  ShareListItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShareListItem& from);
  void MergeFrom(const ShareListItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 share_index = 1;
  inline bool has_share_index() const;
  inline void clear_share_index();
  static const int kShareIndexFieldNumber = 1;
  inline ::google::protobuf::int32 share_index() const;
  inline void set_share_index(::google::protobuf::int32 value);

  // required uint32 create_time = 2;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 create_time() const;
  inline void set_create_time(::google::protobuf::uint32 value);

  // required uint32 exist_period = 3;
  inline bool has_exist_period() const;
  inline void clear_exist_period();
  static const int kExistPeriodFieldNumber = 3;
  inline ::google::protobuf::uint32 exist_period() const;
  inline void set_exist_period(::google::protobuf::uint32 value);

  // required bytes friend_channelid = 4;
  inline bool has_friend_channelid() const;
  inline void clear_friend_channelid();
  static const int kFriendChannelidFieldNumber = 4;
  inline const ::std::string& friend_channelid() const;
  inline void set_friend_channelid(const ::std::string& value);
  inline void set_friend_channelid(const char* value);
  inline void set_friend_channelid(const void* value, size_t size);
  inline ::std::string* mutable_friend_channelid();
  inline ::std::string* release_friend_channelid();
  inline void set_allocated_friend_channelid(::std::string* friend_channelid);

  // repeated .peersafe.share.ShareListSubItem sub_item = 5;
  inline int sub_item_size() const;
  inline void clear_sub_item();
  static const int kSubItemFieldNumber = 5;
  inline const ::peersafe::share::ShareListSubItem& sub_item(int index) const;
  inline ::peersafe::share::ShareListSubItem* mutable_sub_item(int index);
  inline ::peersafe::share::ShareListSubItem* add_sub_item();
  inline const ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareListSubItem >&
      sub_item() const;
  inline ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareListSubItem >*
      mutable_sub_item();

  // @@protoc_insertion_point(class_scope:peersafe.share.ShareListItem)
 private:
  inline void set_has_share_index();
  inline void clear_has_share_index();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_exist_period();
  inline void clear_has_exist_period();
  inline void set_has_friend_channelid();
  inline void clear_has_friend_channelid();

  ::google::protobuf::int32 share_index_;
  ::google::protobuf::uint32 create_time_;
  ::std::string* friend_channelid_;
  ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareListSubItem > sub_item_;
  ::google::protobuf::uint32 exist_period_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_share_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_share_2eproto();
  #endif
  friend void protobuf_AssignDesc_share_2eproto();
  friend void protobuf_ShutdownFile_share_2eproto();

  void InitAsDefaultInstance();
  static ShareListItem* default_instance_;
};
// -------------------------------------------------------------------

class ShareList : public ::google::protobuf::MessageLite {
 public:
  ShareList();
  virtual ~ShareList();

  ShareList(const ShareList& from);

  inline ShareList& operator=(const ShareList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShareList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShareList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShareList* other);

  // implements Message ----------------------------------------------

  ShareList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShareList& from);
  void MergeFrom(const ShareList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes share_list_hash = 1;
  inline bool has_share_list_hash() const;
  inline void clear_share_list_hash();
  static const int kShareListHashFieldNumber = 1;
  inline const ::std::string& share_list_hash() const;
  inline void set_share_list_hash(const ::std::string& value);
  inline void set_share_list_hash(const char* value);
  inline void set_share_list_hash(const void* value, size_t size);
  inline ::std::string* mutable_share_list_hash();
  inline ::std::string* release_share_list_hash();
  inline void set_allocated_share_list_hash(::std::string* share_list_hash);

  // repeated .peersafe.share.ShareListItem share_item = 2;
  inline int share_item_size() const;
  inline void clear_share_item();
  static const int kShareItemFieldNumber = 2;
  inline const ::peersafe::share::ShareListItem& share_item(int index) const;
  inline ::peersafe::share::ShareListItem* mutable_share_item(int index);
  inline ::peersafe::share::ShareListItem* add_share_item();
  inline const ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareListItem >&
      share_item() const;
  inline ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareListItem >*
      mutable_share_item();

  // @@protoc_insertion_point(class_scope:peersafe.share.ShareList)
 private:
  inline void set_has_share_list_hash();
  inline void clear_has_share_list_hash();

  ::std::string* share_list_hash_;
  ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareListItem > share_item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_share_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_share_2eproto();
  #endif
  friend void protobuf_AssignDesc_share_2eproto();
  friend void protobuf_ShutdownFile_share_2eproto();

  void InitAsDefaultInstance();
  static ShareList* default_instance_;
};
// -------------------------------------------------------------------

class ShareSubCommen : public ::google::protobuf::MessageLite {
 public:
  ShareSubCommen();
  virtual ~ShareSubCommen();

  ShareSubCommen(const ShareSubCommen& from);

  inline ShareSubCommen& operator=(const ShareSubCommen& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShareSubCommen& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShareSubCommen* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShareSubCommen* other);

  // implements Message ----------------------------------------------

  ShareSubCommen* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShareSubCommen& from);
  void MergeFrom(const ShareSubCommen& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 create_time = 1;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 create_time() const;
  inline void set_create_time(::google::protobuf::uint32 value);

  // required bytes friend_channel_id = 2;
  inline bool has_friend_channel_id() const;
  inline void clear_friend_channel_id();
  static const int kFriendChannelIdFieldNumber = 2;
  inline const ::std::string& friend_channel_id() const;
  inline void set_friend_channel_id(const ::std::string& value);
  inline void set_friend_channel_id(const char* value);
  inline void set_friend_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_friend_channel_id();
  inline ::std::string* release_friend_channel_id();
  inline void set_allocated_friend_channel_id(::std::string* friend_channel_id);

  // required bytes comment_data = 3;
  inline bool has_comment_data() const;
  inline void clear_comment_data();
  static const int kCommentDataFieldNumber = 3;
  inline const ::std::string& comment_data() const;
  inline void set_comment_data(const ::std::string& value);
  inline void set_comment_data(const char* value);
  inline void set_comment_data(const void* value, size_t size);
  inline ::std::string* mutable_comment_data();
  inline ::std::string* release_comment_data();
  inline void set_allocated_comment_data(::std::string* comment_data);

  // @@protoc_insertion_point(class_scope:peersafe.share.ShareSubCommen)
 private:
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_friend_channel_id();
  inline void clear_has_friend_channel_id();
  inline void set_has_comment_data();
  inline void clear_has_comment_data();

  ::std::string* friend_channel_id_;
  ::std::string* comment_data_;
  ::google::protobuf::uint32 create_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_share_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_share_2eproto();
  #endif
  friend void protobuf_AssignDesc_share_2eproto();
  friend void protobuf_ShutdownFile_share_2eproto();

  void InitAsDefaultInstance();
  static ShareSubCommen* default_instance_;
};
// -------------------------------------------------------------------

class ShareComment : public ::google::protobuf::MessageLite {
 public:
  ShareComment();
  virtual ~ShareComment();

  ShareComment(const ShareComment& from);

  inline ShareComment& operator=(const ShareComment& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShareComment& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShareComment* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShareComment* other);

  // implements Message ----------------------------------------------

  ShareComment* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShareComment& from);
  void MergeFrom(const ShareComment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .peersafe.share.ShareSubCommen every_comment = 1;
  inline int every_comment_size() const;
  inline void clear_every_comment();
  static const int kEveryCommentFieldNumber = 1;
  inline const ::peersafe::share::ShareSubCommen& every_comment(int index) const;
  inline ::peersafe::share::ShareSubCommen* mutable_every_comment(int index);
  inline ::peersafe::share::ShareSubCommen* add_every_comment();
  inline const ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareSubCommen >&
      every_comment() const;
  inline ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareSubCommen >*
      mutable_every_comment();

  // @@protoc_insertion_point(class_scope:peersafe.share.ShareComment)
 private:

  ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareSubCommen > every_comment_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_share_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_share_2eproto();
  #endif
  friend void protobuf_AssignDesc_share_2eproto();
  friend void protobuf_ShutdownFile_share_2eproto();

  void InitAsDefaultInstance();
  static ShareComment* default_instance_;
};
// -------------------------------------------------------------------

class ShareContent : public ::google::protobuf::MessageLite {
 public:
  ShareContent();
  virtual ~ShareContent();

  ShareContent(const ShareContent& from);

  inline ShareContent& operator=(const ShareContent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShareContent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShareContent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShareContent* other);

  // implements Message ----------------------------------------------

  ShareContent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShareContent& from);
  void MergeFrom(const ShareContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes content_data = 1;
  inline bool has_content_data() const;
  inline void clear_content_data();
  static const int kContentDataFieldNumber = 1;
  inline const ::std::string& content_data() const;
  inline void set_content_data(const ::std::string& value);
  inline void set_content_data(const char* value);
  inline void set_content_data(const void* value, size_t size);
  inline ::std::string* mutable_content_data();
  inline ::std::string* release_content_data();
  inline void set_allocated_content_data(::std::string* content_data);

  // @@protoc_insertion_point(class_scope:peersafe.share.ShareContent)
 private:
  inline void set_has_content_data();
  inline void clear_has_content_data();

  ::std::string* content_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_share_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_share_2eproto();
  #endif
  friend void protobuf_AssignDesc_share_2eproto();
  friend void protobuf_ShutdownFile_share_2eproto();

  void InitAsDefaultInstance();
  static ShareContent* default_instance_;
};
// ===================================================================


// ===================================================================

// ShareFile

// required .peersafe.share.ShareFile.FileType file_type = 1;
inline bool ShareFile::has_file_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShareFile::set_has_file_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShareFile::clear_has_file_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShareFile::clear_file_type() {
  file_type_ = 1;
  clear_has_file_type();
}
inline ::peersafe::share::ShareFile_FileType ShareFile::file_type() const {
  return static_cast< ::peersafe::share::ShareFile_FileType >(file_type_);
}
inline void ShareFile::set_file_type(::peersafe::share::ShareFile_FileType value) {
  assert(::peersafe::share::ShareFile_FileType_IsValid(value));
  set_has_file_type();
  file_type_ = value;
}

// optional bytes file_data = 2;
inline bool ShareFile::has_file_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShareFile::set_has_file_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShareFile::clear_has_file_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShareFile::clear_file_data() {
  if (file_data_ != &::google::protobuf::internal::GetEmptyString()) {
    file_data_->clear();
  }
  clear_has_file_data();
}
inline const ::std::string& ShareFile::file_data() const {
  return *file_data_;
}
inline void ShareFile::set_file_data(const ::std::string& value) {
  set_has_file_data();
  if (file_data_ == &::google::protobuf::internal::GetEmptyString()) {
    file_data_ = new ::std::string;
  }
  file_data_->assign(value);
}
inline void ShareFile::set_file_data(const char* value) {
  set_has_file_data();
  if (file_data_ == &::google::protobuf::internal::GetEmptyString()) {
    file_data_ = new ::std::string;
  }
  file_data_->assign(value);
}
inline void ShareFile::set_file_data(const void* value, size_t size) {
  set_has_file_data();
  if (file_data_ == &::google::protobuf::internal::GetEmptyString()) {
    file_data_ = new ::std::string;
  }
  file_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareFile::mutable_file_data() {
  set_has_file_data();
  if (file_data_ == &::google::protobuf::internal::GetEmptyString()) {
    file_data_ = new ::std::string;
  }
  return file_data_;
}
inline ::std::string* ShareFile::release_file_data() {
  clear_has_file_data();
  if (file_data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = file_data_;
    file_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShareFile::set_allocated_file_data(::std::string* file_data) {
  if (file_data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete file_data_;
  }
  if (file_data) {
    set_has_file_data();
    file_data_ = file_data;
  } else {
    clear_has_file_data();
    file_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// ShareListSubItem

// required uint32 share_content_type = 1;
inline bool ShareListSubItem::has_share_content_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShareListSubItem::set_has_share_content_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShareListSubItem::clear_has_share_content_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShareListSubItem::clear_share_content_type() {
  share_content_type_ = 0u;
  clear_has_share_content_type();
}
inline ::google::protobuf::uint32 ShareListSubItem::share_content_type() const {
  return share_content_type_;
}
inline void ShareListSubItem::set_share_content_type(::google::protobuf::uint32 value) {
  set_has_share_content_type();
  share_content_type_ = value;
}

// required bytes share_file_name = 2;
inline bool ShareListSubItem::has_share_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShareListSubItem::set_has_share_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShareListSubItem::clear_has_share_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShareListSubItem::clear_share_file_name() {
  if (share_file_name_ != &::google::protobuf::internal::GetEmptyString()) {
    share_file_name_->clear();
  }
  clear_has_share_file_name();
}
inline const ::std::string& ShareListSubItem::share_file_name() const {
  return *share_file_name_;
}
inline void ShareListSubItem::set_share_file_name(const ::std::string& value) {
  set_has_share_file_name();
  if (share_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    share_file_name_ = new ::std::string;
  }
  share_file_name_->assign(value);
}
inline void ShareListSubItem::set_share_file_name(const char* value) {
  set_has_share_file_name();
  if (share_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    share_file_name_ = new ::std::string;
  }
  share_file_name_->assign(value);
}
inline void ShareListSubItem::set_share_file_name(const void* value, size_t size) {
  set_has_share_file_name();
  if (share_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    share_file_name_ = new ::std::string;
  }
  share_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareListSubItem::mutable_share_file_name() {
  set_has_share_file_name();
  if (share_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    share_file_name_ = new ::std::string;
  }
  return share_file_name_;
}
inline ::std::string* ShareListSubItem::release_share_file_name() {
  clear_has_share_file_name();
  if (share_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = share_file_name_;
    share_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShareListSubItem::set_allocated_share_file_name(::std::string* share_file_name) {
  if (share_file_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete share_file_name_;
  }
  if (share_file_name) {
    set_has_share_file_name();
    share_file_name_ = share_file_name;
  } else {
    clear_has_share_file_name();
    share_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes thumbnail_file_name = 3;
inline bool ShareListSubItem::has_thumbnail_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShareListSubItem::set_has_thumbnail_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShareListSubItem::clear_has_thumbnail_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShareListSubItem::clear_thumbnail_file_name() {
  if (thumbnail_file_name_ != &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_file_name_->clear();
  }
  clear_has_thumbnail_file_name();
}
inline const ::std::string& ShareListSubItem::thumbnail_file_name() const {
  return *thumbnail_file_name_;
}
inline void ShareListSubItem::set_thumbnail_file_name(const ::std::string& value) {
  set_has_thumbnail_file_name();
  if (thumbnail_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_file_name_ = new ::std::string;
  }
  thumbnail_file_name_->assign(value);
}
inline void ShareListSubItem::set_thumbnail_file_name(const char* value) {
  set_has_thumbnail_file_name();
  if (thumbnail_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_file_name_ = new ::std::string;
  }
  thumbnail_file_name_->assign(value);
}
inline void ShareListSubItem::set_thumbnail_file_name(const void* value, size_t size) {
  set_has_thumbnail_file_name();
  if (thumbnail_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_file_name_ = new ::std::string;
  }
  thumbnail_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareListSubItem::mutable_thumbnail_file_name() {
  set_has_thumbnail_file_name();
  if (thumbnail_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_file_name_ = new ::std::string;
  }
  return thumbnail_file_name_;
}
inline ::std::string* ShareListSubItem::release_thumbnail_file_name() {
  clear_has_thumbnail_file_name();
  if (thumbnail_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = thumbnail_file_name_;
    thumbnail_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShareListSubItem::set_allocated_thumbnail_file_name(::std::string* thumbnail_file_name) {
  if (thumbnail_file_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete thumbnail_file_name_;
  }
  if (thumbnail_file_name) {
    set_has_thumbnail_file_name();
    thumbnail_file_name_ = thumbnail_file_name;
  } else {
    clear_has_thumbnail_file_name();
    thumbnail_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes thumbnail_data = 4;
inline bool ShareListSubItem::has_thumbnail_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShareListSubItem::set_has_thumbnail_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShareListSubItem::clear_has_thumbnail_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShareListSubItem::clear_thumbnail_data() {
  if (thumbnail_data_ != &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_data_->clear();
  }
  clear_has_thumbnail_data();
}
inline const ::std::string& ShareListSubItem::thumbnail_data() const {
  return *thumbnail_data_;
}
inline void ShareListSubItem::set_thumbnail_data(const ::std::string& value) {
  set_has_thumbnail_data();
  if (thumbnail_data_ == &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_data_ = new ::std::string;
  }
  thumbnail_data_->assign(value);
}
inline void ShareListSubItem::set_thumbnail_data(const char* value) {
  set_has_thumbnail_data();
  if (thumbnail_data_ == &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_data_ = new ::std::string;
  }
  thumbnail_data_->assign(value);
}
inline void ShareListSubItem::set_thumbnail_data(const void* value, size_t size) {
  set_has_thumbnail_data();
  if (thumbnail_data_ == &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_data_ = new ::std::string;
  }
  thumbnail_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareListSubItem::mutable_thumbnail_data() {
  set_has_thumbnail_data();
  if (thumbnail_data_ == &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_data_ = new ::std::string;
  }
  return thumbnail_data_;
}
inline ::std::string* ShareListSubItem::release_thumbnail_data() {
  clear_has_thumbnail_data();
  if (thumbnail_data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = thumbnail_data_;
    thumbnail_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShareListSubItem::set_allocated_thumbnail_data(::std::string* thumbnail_data) {
  if (thumbnail_data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete thumbnail_data_;
  }
  if (thumbnail_data) {
    set_has_thumbnail_data();
    thumbnail_data_ = thumbnail_data;
  } else {
    clear_has_thumbnail_data();
    thumbnail_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes share_content_hash = 5;
inline bool ShareListSubItem::has_share_content_hash() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShareListSubItem::set_has_share_content_hash() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShareListSubItem::clear_has_share_content_hash() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShareListSubItem::clear_share_content_hash() {
  if (share_content_hash_ != &::google::protobuf::internal::GetEmptyString()) {
    share_content_hash_->clear();
  }
  clear_has_share_content_hash();
}
inline const ::std::string& ShareListSubItem::share_content_hash() const {
  return *share_content_hash_;
}
inline void ShareListSubItem::set_share_content_hash(const ::std::string& value) {
  set_has_share_content_hash();
  if (share_content_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    share_content_hash_ = new ::std::string;
  }
  share_content_hash_->assign(value);
}
inline void ShareListSubItem::set_share_content_hash(const char* value) {
  set_has_share_content_hash();
  if (share_content_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    share_content_hash_ = new ::std::string;
  }
  share_content_hash_->assign(value);
}
inline void ShareListSubItem::set_share_content_hash(const void* value, size_t size) {
  set_has_share_content_hash();
  if (share_content_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    share_content_hash_ = new ::std::string;
  }
  share_content_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareListSubItem::mutable_share_content_hash() {
  set_has_share_content_hash();
  if (share_content_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    share_content_hash_ = new ::std::string;
  }
  return share_content_hash_;
}
inline ::std::string* ShareListSubItem::release_share_content_hash() {
  clear_has_share_content_hash();
  if (share_content_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = share_content_hash_;
    share_content_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShareListSubItem::set_allocated_share_content_hash(::std::string* share_content_hash) {
  if (share_content_hash_ != &::google::protobuf::internal::GetEmptyString()) {
    delete share_content_hash_;
  }
  if (share_content_hash) {
    set_has_share_content_hash();
    share_content_hash_ = share_content_hash;
  } else {
    clear_has_share_content_hash();
    share_content_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes share_comment_hash = 6;
inline bool ShareListSubItem::has_share_comment_hash() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShareListSubItem::set_has_share_comment_hash() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ShareListSubItem::clear_has_share_comment_hash() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ShareListSubItem::clear_share_comment_hash() {
  if (share_comment_hash_ != &::google::protobuf::internal::GetEmptyString()) {
    share_comment_hash_->clear();
  }
  clear_has_share_comment_hash();
}
inline const ::std::string& ShareListSubItem::share_comment_hash() const {
  return *share_comment_hash_;
}
inline void ShareListSubItem::set_share_comment_hash(const ::std::string& value) {
  set_has_share_comment_hash();
  if (share_comment_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    share_comment_hash_ = new ::std::string;
  }
  share_comment_hash_->assign(value);
}
inline void ShareListSubItem::set_share_comment_hash(const char* value) {
  set_has_share_comment_hash();
  if (share_comment_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    share_comment_hash_ = new ::std::string;
  }
  share_comment_hash_->assign(value);
}
inline void ShareListSubItem::set_share_comment_hash(const void* value, size_t size) {
  set_has_share_comment_hash();
  if (share_comment_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    share_comment_hash_ = new ::std::string;
  }
  share_comment_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareListSubItem::mutable_share_comment_hash() {
  set_has_share_comment_hash();
  if (share_comment_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    share_comment_hash_ = new ::std::string;
  }
  return share_comment_hash_;
}
inline ::std::string* ShareListSubItem::release_share_comment_hash() {
  clear_has_share_comment_hash();
  if (share_comment_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = share_comment_hash_;
    share_comment_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShareListSubItem::set_allocated_share_comment_hash(::std::string* share_comment_hash) {
  if (share_comment_hash_ != &::google::protobuf::internal::GetEmptyString()) {
    delete share_comment_hash_;
  }
  if (share_comment_hash) {
    set_has_share_comment_hash();
    share_comment_hash_ = share_comment_hash;
  } else {
    clear_has_share_comment_hash();
    share_comment_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// ShareListItem

// required int32 share_index = 1;
inline bool ShareListItem::has_share_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShareListItem::set_has_share_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShareListItem::clear_has_share_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShareListItem::clear_share_index() {
  share_index_ = 0;
  clear_has_share_index();
}
inline ::google::protobuf::int32 ShareListItem::share_index() const {
  return share_index_;
}
inline void ShareListItem::set_share_index(::google::protobuf::int32 value) {
  set_has_share_index();
  share_index_ = value;
}

// required uint32 create_time = 2;
inline bool ShareListItem::has_create_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShareListItem::set_has_create_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShareListItem::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShareListItem::clear_create_time() {
  create_time_ = 0u;
  clear_has_create_time();
}
inline ::google::protobuf::uint32 ShareListItem::create_time() const {
  return create_time_;
}
inline void ShareListItem::set_create_time(::google::protobuf::uint32 value) {
  set_has_create_time();
  create_time_ = value;
}

// required uint32 exist_period = 3;
inline bool ShareListItem::has_exist_period() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShareListItem::set_has_exist_period() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShareListItem::clear_has_exist_period() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShareListItem::clear_exist_period() {
  exist_period_ = 0u;
  clear_has_exist_period();
}
inline ::google::protobuf::uint32 ShareListItem::exist_period() const {
  return exist_period_;
}
inline void ShareListItem::set_exist_period(::google::protobuf::uint32 value) {
  set_has_exist_period();
  exist_period_ = value;
}

// required bytes friend_channelid = 4;
inline bool ShareListItem::has_friend_channelid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShareListItem::set_has_friend_channelid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShareListItem::clear_has_friend_channelid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShareListItem::clear_friend_channelid() {
  if (friend_channelid_ != &::google::protobuf::internal::GetEmptyString()) {
    friend_channelid_->clear();
  }
  clear_has_friend_channelid();
}
inline const ::std::string& ShareListItem::friend_channelid() const {
  return *friend_channelid_;
}
inline void ShareListItem::set_friend_channelid(const ::std::string& value) {
  set_has_friend_channelid();
  if (friend_channelid_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channelid_ = new ::std::string;
  }
  friend_channelid_->assign(value);
}
inline void ShareListItem::set_friend_channelid(const char* value) {
  set_has_friend_channelid();
  if (friend_channelid_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channelid_ = new ::std::string;
  }
  friend_channelid_->assign(value);
}
inline void ShareListItem::set_friend_channelid(const void* value, size_t size) {
  set_has_friend_channelid();
  if (friend_channelid_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channelid_ = new ::std::string;
  }
  friend_channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareListItem::mutable_friend_channelid() {
  set_has_friend_channelid();
  if (friend_channelid_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channelid_ = new ::std::string;
  }
  return friend_channelid_;
}
inline ::std::string* ShareListItem::release_friend_channelid() {
  clear_has_friend_channelid();
  if (friend_channelid_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = friend_channelid_;
    friend_channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShareListItem::set_allocated_friend_channelid(::std::string* friend_channelid) {
  if (friend_channelid_ != &::google::protobuf::internal::GetEmptyString()) {
    delete friend_channelid_;
  }
  if (friend_channelid) {
    set_has_friend_channelid();
    friend_channelid_ = friend_channelid;
  } else {
    clear_has_friend_channelid();
    friend_channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .peersafe.share.ShareListSubItem sub_item = 5;
inline int ShareListItem::sub_item_size() const {
  return sub_item_.size();
}
inline void ShareListItem::clear_sub_item() {
  sub_item_.Clear();
}
inline const ::peersafe::share::ShareListSubItem& ShareListItem::sub_item(int index) const {
  return sub_item_.Get(index);
}
inline ::peersafe::share::ShareListSubItem* ShareListItem::mutable_sub_item(int index) {
  return sub_item_.Mutable(index);
}
inline ::peersafe::share::ShareListSubItem* ShareListItem::add_sub_item() {
  return sub_item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareListSubItem >&
ShareListItem::sub_item() const {
  return sub_item_;
}
inline ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareListSubItem >*
ShareListItem::mutable_sub_item() {
  return &sub_item_;
}

// -------------------------------------------------------------------

// ShareList

// required bytes share_list_hash = 1;
inline bool ShareList::has_share_list_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShareList::set_has_share_list_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShareList::clear_has_share_list_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShareList::clear_share_list_hash() {
  if (share_list_hash_ != &::google::protobuf::internal::GetEmptyString()) {
    share_list_hash_->clear();
  }
  clear_has_share_list_hash();
}
inline const ::std::string& ShareList::share_list_hash() const {
  return *share_list_hash_;
}
inline void ShareList::set_share_list_hash(const ::std::string& value) {
  set_has_share_list_hash();
  if (share_list_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    share_list_hash_ = new ::std::string;
  }
  share_list_hash_->assign(value);
}
inline void ShareList::set_share_list_hash(const char* value) {
  set_has_share_list_hash();
  if (share_list_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    share_list_hash_ = new ::std::string;
  }
  share_list_hash_->assign(value);
}
inline void ShareList::set_share_list_hash(const void* value, size_t size) {
  set_has_share_list_hash();
  if (share_list_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    share_list_hash_ = new ::std::string;
  }
  share_list_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareList::mutable_share_list_hash() {
  set_has_share_list_hash();
  if (share_list_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    share_list_hash_ = new ::std::string;
  }
  return share_list_hash_;
}
inline ::std::string* ShareList::release_share_list_hash() {
  clear_has_share_list_hash();
  if (share_list_hash_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = share_list_hash_;
    share_list_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShareList::set_allocated_share_list_hash(::std::string* share_list_hash) {
  if (share_list_hash_ != &::google::protobuf::internal::GetEmptyString()) {
    delete share_list_hash_;
  }
  if (share_list_hash) {
    set_has_share_list_hash();
    share_list_hash_ = share_list_hash;
  } else {
    clear_has_share_list_hash();
    share_list_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .peersafe.share.ShareListItem share_item = 2;
inline int ShareList::share_item_size() const {
  return share_item_.size();
}
inline void ShareList::clear_share_item() {
  share_item_.Clear();
}
inline const ::peersafe::share::ShareListItem& ShareList::share_item(int index) const {
  return share_item_.Get(index);
}
inline ::peersafe::share::ShareListItem* ShareList::mutable_share_item(int index) {
  return share_item_.Mutable(index);
}
inline ::peersafe::share::ShareListItem* ShareList::add_share_item() {
  return share_item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareListItem >&
ShareList::share_item() const {
  return share_item_;
}
inline ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareListItem >*
ShareList::mutable_share_item() {
  return &share_item_;
}

// -------------------------------------------------------------------

// ShareSubCommen

// required uint32 create_time = 1;
inline bool ShareSubCommen::has_create_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShareSubCommen::set_has_create_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShareSubCommen::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShareSubCommen::clear_create_time() {
  create_time_ = 0u;
  clear_has_create_time();
}
inline ::google::protobuf::uint32 ShareSubCommen::create_time() const {
  return create_time_;
}
inline void ShareSubCommen::set_create_time(::google::protobuf::uint32 value) {
  set_has_create_time();
  create_time_ = value;
}

// required bytes friend_channel_id = 2;
inline bool ShareSubCommen::has_friend_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShareSubCommen::set_has_friend_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShareSubCommen::clear_has_friend_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShareSubCommen::clear_friend_channel_id() {
  if (friend_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_->clear();
  }
  clear_has_friend_channel_id();
}
inline const ::std::string& ShareSubCommen::friend_channel_id() const {
  return *friend_channel_id_;
}
inline void ShareSubCommen::set_friend_channel_id(const ::std::string& value) {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  friend_channel_id_->assign(value);
}
inline void ShareSubCommen::set_friend_channel_id(const char* value) {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  friend_channel_id_->assign(value);
}
inline void ShareSubCommen::set_friend_channel_id(const void* value, size_t size) {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  friend_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareSubCommen::mutable_friend_channel_id() {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  return friend_channel_id_;
}
inline ::std::string* ShareSubCommen::release_friend_channel_id() {
  clear_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = friend_channel_id_;
    friend_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShareSubCommen::set_allocated_friend_channel_id(::std::string* friend_channel_id) {
  if (friend_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete friend_channel_id_;
  }
  if (friend_channel_id) {
    set_has_friend_channel_id();
    friend_channel_id_ = friend_channel_id;
  } else {
    clear_has_friend_channel_id();
    friend_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes comment_data = 3;
inline bool ShareSubCommen::has_comment_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShareSubCommen::set_has_comment_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShareSubCommen::clear_has_comment_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShareSubCommen::clear_comment_data() {
  if (comment_data_ != &::google::protobuf::internal::GetEmptyString()) {
    comment_data_->clear();
  }
  clear_has_comment_data();
}
inline const ::std::string& ShareSubCommen::comment_data() const {
  return *comment_data_;
}
inline void ShareSubCommen::set_comment_data(const ::std::string& value) {
  set_has_comment_data();
  if (comment_data_ == &::google::protobuf::internal::GetEmptyString()) {
    comment_data_ = new ::std::string;
  }
  comment_data_->assign(value);
}
inline void ShareSubCommen::set_comment_data(const char* value) {
  set_has_comment_data();
  if (comment_data_ == &::google::protobuf::internal::GetEmptyString()) {
    comment_data_ = new ::std::string;
  }
  comment_data_->assign(value);
}
inline void ShareSubCommen::set_comment_data(const void* value, size_t size) {
  set_has_comment_data();
  if (comment_data_ == &::google::protobuf::internal::GetEmptyString()) {
    comment_data_ = new ::std::string;
  }
  comment_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareSubCommen::mutable_comment_data() {
  set_has_comment_data();
  if (comment_data_ == &::google::protobuf::internal::GetEmptyString()) {
    comment_data_ = new ::std::string;
  }
  return comment_data_;
}
inline ::std::string* ShareSubCommen::release_comment_data() {
  clear_has_comment_data();
  if (comment_data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = comment_data_;
    comment_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShareSubCommen::set_allocated_comment_data(::std::string* comment_data) {
  if (comment_data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete comment_data_;
  }
  if (comment_data) {
    set_has_comment_data();
    comment_data_ = comment_data;
  } else {
    clear_has_comment_data();
    comment_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// ShareComment

// repeated .peersafe.share.ShareSubCommen every_comment = 1;
inline int ShareComment::every_comment_size() const {
  return every_comment_.size();
}
inline void ShareComment::clear_every_comment() {
  every_comment_.Clear();
}
inline const ::peersafe::share::ShareSubCommen& ShareComment::every_comment(int index) const {
  return every_comment_.Get(index);
}
inline ::peersafe::share::ShareSubCommen* ShareComment::mutable_every_comment(int index) {
  return every_comment_.Mutable(index);
}
inline ::peersafe::share::ShareSubCommen* ShareComment::add_every_comment() {
  return every_comment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareSubCommen >&
ShareComment::every_comment() const {
  return every_comment_;
}
inline ::google::protobuf::RepeatedPtrField< ::peersafe::share::ShareSubCommen >*
ShareComment::mutable_every_comment() {
  return &every_comment_;
}

// -------------------------------------------------------------------

// ShareContent

// required bytes content_data = 1;
inline bool ShareContent::has_content_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShareContent::set_has_content_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShareContent::clear_has_content_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShareContent::clear_content_data() {
  if (content_data_ != &::google::protobuf::internal::GetEmptyString()) {
    content_data_->clear();
  }
  clear_has_content_data();
}
inline const ::std::string& ShareContent::content_data() const {
  return *content_data_;
}
inline void ShareContent::set_content_data(const ::std::string& value) {
  set_has_content_data();
  if (content_data_ == &::google::protobuf::internal::GetEmptyString()) {
    content_data_ = new ::std::string;
  }
  content_data_->assign(value);
}
inline void ShareContent::set_content_data(const char* value) {
  set_has_content_data();
  if (content_data_ == &::google::protobuf::internal::GetEmptyString()) {
    content_data_ = new ::std::string;
  }
  content_data_->assign(value);
}
inline void ShareContent::set_content_data(const void* value, size_t size) {
  set_has_content_data();
  if (content_data_ == &::google::protobuf::internal::GetEmptyString()) {
    content_data_ = new ::std::string;
  }
  content_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareContent::mutable_content_data() {
  set_has_content_data();
  if (content_data_ == &::google::protobuf::internal::GetEmptyString()) {
    content_data_ = new ::std::string;
  }
  return content_data_;
}
inline ::std::string* ShareContent::release_content_data() {
  clear_has_content_data();
  if (content_data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = content_data_;
    content_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShareContent::set_allocated_content_data(::std::string* content_data) {
  if (content_data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete content_data_;
  }
  if (content_data) {
    set_has_content_data();
    content_data_ = content_data;
  } else {
    clear_has_content_data();
    content_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace share
}  // namespace peersafe

// @@protoc_insertion_point(global_scope)

#ifdef _MSC_VER
#  pragma warning(pop)
#endif

#endif  // PROTOBUF_share_2eproto__INCLUDED
